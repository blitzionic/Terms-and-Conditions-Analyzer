import fs from 'fs';
import Url from 'url';
import Path from 'path';
import test from 'tape';
import HAREntry from './../../lib/har-entry';
import HARResponse from './../../lib/har-response';

const HARFILE = Path.normalize(__dirname + '/../fixtures/www.fixtitious.site/site.har');
const har = fs.readFileSync(HARFILE);

const setup = () => {
  const json = JSON.parse(har);
  return json.log.entries.pop().response;
}

const img = () => {
  return {
    "status": 200,
    "statusText": "OK",
    "httpVersion": "HTTP/1.1",
    "headers": [
      {
        "name": "Date",
        "value": "Sat, 08 Oct 2016 23:54:51 GMT"
      },
      {
        "name": "Last-Modified",
        "value": "Sat, 08 Oct 2016 23:50:50 GMT"
      },
      {
        "name": "X-Powered-By",
        "value": "Express"
      },
      {
        "name": "ETag",
        "value": "W/\"126-157a6b4cf90\""
      },
      {
        "name": "Content-Type",
        "value": "image/png"
      },
      {
        "name": "Cache-Control",
        "value": "public, max-age=0"
      },
      {
        "name": "Connection",
        "value": "keep-alive"
      },
      {
        "name": "Accept-Ranges",
        "value": "bytes"
      },
      {
        "name": "Content-Length",
        "value": "294"
      }
    ],
    "cookies": [],
    "content": {
      "size": 98,
      "mimeType": "image/png",
      "text": "R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=="
    },
    "redirectURL": "",
    "headersSize": 278,
    "bodySize": 98,
    "_transferSize": 376
  }
}

test('A HARResponse is a HARResponse', (assert) => {
  const fixture = setup();
  const sut = new HARResponse(fixture);

  assert.true(sut instanceof HARResponse);
  assert.end();
});

test('A HARResponse should have a status property correctly set', (assert) => {
  const fixture = setup();
  const sut = new HARResponse(fixture);

  assert.equals(sut.status, 304);
  assert.end();
});

test('A HARResponse should have a statusText property correctly set', (assert) => {
  const fixture = setup();
  const sut = new HARResponse(fixture);

  assert.equals(sut.statusText, 'Not Modified');
  assert.end();
});

test('A HARResponse should have a headers property correctly set', (assert) => {
  const fixture = setup();
  const sut = new HARResponse(fixture);
  const expected = { 
    'Date': 'Sat, 08 Oct 2016 23:55:01 GMT',
    'Cache-Control': 'public, max-age=0',
    'Last-Modified': 'Sat, 08 Oct 2016 23:49:32 GMT',
    'Connection': 'keep-alive',
    'Accept-Ranges': 'bytes',
    'X-Powered-By': 'Express',
    'ETag': 'W/"d0-157a6b39ee0"' 
  };
  assert.deepEquals(sut.headers, expected);
  assert.end();
});

test('A HARResponse should have a cookies property correctly set', (assert) => {
  const fixture = setup();
  const sut = new HARResponse(fixture);

  assert.deepEquals(sut.cookies, {});
  assert.end();
});

test('A HARResponse should have a content property correctly set', (assert) => {
  const fixture = setup();
  const sut = new HARResponse(fixture);
  const expected = {
    size: 208,
    mimeType: 'text/html',
    text: "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <title>Page Number Two</title>\n</head>\n<body>\n<h1>This is page number two!</h1>\n<a href=\"http://www.fixtitious.site:2224/one.html\">< previous page</a>\n</body>\n</html>"
  }
  assert.deepEquals(sut.content, expected);
  assert.end();
});

test('A HARResponse should have a body property correctly set', (assert) => {
  const fixture = setup();
  let sut = new HARResponse(fixture);
  let expected = "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <title>Page Number Two</title>\n</head>\n<body>\n<h1>This is page number two!</h1>\n<a href=\"http://www.fixtitious.site:2224/one.html\">< previous page</a>\n</body>\n</html>";
  
  assert.equals(sut.body, expected);

  fixture.content.text = undefined;
  sut = new HARResponse(fixture);

  assert.equals(typeof sut.body, 'string');
  assert.end();
});

test('A HARResponse should have a redirectURL property correctly set', (assert) => {
  const fixture = setup();
  const sut = new HARResponse(fixture);
  
  assert.equals(sut.redirectURL, "");
  assert.end();
});

test('A HARResponse should have a headersSize property correctly set', (assert) => {
  const fixture = setup();
  const sut = new HARResponse(fixture);
  
  assert.deepEquals(sut.headersSize, 241);
  assert.end();
});

test('A HARResponse should have a bodySize property correctly set', (assert) => {
  const fixture = setup();
  const sut = new HARResponse(fixture);
  
  assert.deepEquals(sut.bodySize, 0);
  assert.end();
});

test('A HARResponse shoud have a isTextMime method', (assert) => {
  const fixture = setup();
  const sut = new HARResponse(fixture);

  assert.equals(typeof sut.isTextMime, 'function');

  assert.true(sut.isTextMime());

  assert.end();
});

test('A HARResponse should have an isImage method', (assert) => {
  const fixture = setup();
  const sut = new HARResponse(fixture);

  assert.equals(typeof sut.isImage, 'function', 'method should exist');
  assert.equals(typeof sut.isImage(), 'boolean', 'should return boolean');
  assert.false(sut.isImage(), 'should indicate response not of type image/*');

  sut.content.mimeType = 'image/png';

  assert.true(sut.isImage(), 'should indicate response is image if mimeType image/*');

  assert.end();
});

test('A HARResponse image buffer creation', (assert) => {
  const fixture = img();
  const sut = new HARResponse(fixture);
  const Buff = function (text, enc, called = false) {
    this.text = text;
    this.enc = enc;
    this.fromCalled = called;
  }

  Buff.from = (t, e) => { return new Buff(t, e, true) };

  let buf;

  assert.equals(typeof sut._createImageBuffer,'function', 'method should exist');
  assert.equals(sut._createImageBuffer(sut.body) instanceof Buffer, true, 'method should return Buffer');

  // test behvior with different versions
  buf = sut._createImageBuffer(sut.body, 'base64', Buff, 'v4.0.0');
  assert.equals(buf.fromCalled, false, 'method will return Buffer instatiated with new if node v4');

  buf = sut._createImageBuffer(sut.body, 'base64', Buff, 'v5.1.1');
  assert.equals(buf.fromCalled, false, 'method will return Buffer instatiated with new if node v5');

  buf = sut._createImageBuffer(sut.body, 'base64', Buff, 'v6.8.1');
  assert.equals(buf.fromCalled, true, 'method will return Buffer instatiated with `from` method if node v6');

  buf = sut._createImageBuffer(sut.body, 'base64', Buff, 'v7.0.0');
  assert.equals(buf.fromCalled, true, 'method will return Buffer instatiated with `from` method if > v6');

  // test behavior with different encoding
  buf = sut._createImageBuffer(sut.body, 'binary', Buff, 'v5.1.1');
  assert.equals(buf.enc, 'binary', 'method shoul call Buffer with correct encoding');

  buf = sut._createImageBuffer(sut.body, 'latin-1', Buff, 'v6.1.2');
  assert.equals(buf.enc, 'latin-1', 'method should call Buffer with correct encoding at > v5');

  assert.end();
});

test('A HARResponse undertands text vs images', (assert) => {
  const sut = new HARResponse();

  let fixture = setup();
  

  assert.equals(typeof sut._parseBody(fixture), 'string', 'should return a string if mime type not image/*');

  fixture = img();
  assert.equals(sut._parseBody(fixture) instanceof Buffer, true, 'should return a Buffer if mime type is image/*');

  assert.end();
})



